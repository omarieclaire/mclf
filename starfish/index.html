<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pulse Wave - Ocean Dreams</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom, #001122, #003355);
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(150, 220, 255, 0.9);
            z-index: 100;
            text-shadow: 0 0 20px rgba(150, 220, 255, 0.5);
            font-size: 18px;
            font-weight: bold;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(100, 200, 200, 0.9);
            z-index: 100;
            text-shadow: 0 0 20px rgba(100, 200, 200, 0.5);
            text-align: center;
            font-size: 20px;
            font-weight: bold;
        }
        #startButton {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 25px 50px;
            font-size: 24px;
            background: linear-gradient(45deg, #2a5aa0, #4a9fbb);
            border: none;
            border-radius: 12px;
            color: white;
            cursor: pointer;
            z-index: 200;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            box-shadow: 0 0 30px rgba(74, 159, 187, 0.6);
        }
        #startButton:hover {
            transform: translate(-50%, -50%) scale(1.05);
            box-shadow: 0 0 40px rgba(74, 159, 187, 0.8);
        }
        #modelStatus {
            position: absolute;
            top: 120px;
            left: 20px;
            color: rgba(200, 220, 150, 0.9);
            z-index: 100;
            font-size: 14px;
            text-shadow: 0 0 10px rgba(200, 220, 150, 0.5);
        }
        #focusIndicator {
            position: absolute;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 8px;
            border: 1px solid rgba(100, 200, 200, 0.7);
            border-radius: 4px;
            z-index: 100;
            background: rgba(0, 20, 40, 0.7);
        }
        #focusBar {
            height: 100%;
            background: linear-gradient(90deg, #4a9fbb, #7dd3fc);
            border-radius: 3px;
            transition: width 0.2s ease;
            opacity: 0;
        }
        #memoryText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(200, 255, 255, 0.9);
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            text-shadow: 0 0 30px rgba(200, 255, 255, 0.8);
            z-index: 150;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        #zoneIndicator {
            position: absolute;
            top: 70px;
            left: 20px;
            color: rgba(150, 220, 255, 0.9);
            z-index: 100;
            font-size: 16px;
            text-shadow: 0 0 15px rgba(150, 220, 255, 0.5);
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <button id="startButton">ENTER OCEAN DREAMS</button>
        <div id="ui">
            <div>Depth: <span id="depth">0</span>m</div>
            <div>Dreamscape: <span id="experience">Floating...</span></div>
        </div>
        <div id="zoneIndicator">
            Zone: <span id="zoneName">Sunlit Waters</span>
        </div>
        <div id="instructions">
            HOLD SPACEBAR to focus and slow the dream
        </div>
        <div id="focusIndicator">
            <div id="focusBar"></div>
        </div>
        <div id="modelStatus">
            Looking for GLB models...
        </div>
        <div id="memoryText"></div>
    </div>

    <script type="module">
        import * as THREE from './js/node_modules/three/build/three.module.js';
        import { GLTFLoader } from './js/node_modules/three/examples/jsm/loaders/GLTFLoader.js';

        let scene, camera, renderer, audioContext;
        let gameStarted = false;
        let depth = 0;
        let focusMode = false;
        let focusIntensity = 0;
        let time = 0;
        
        // Enhanced world generation
        let worldObjects = [];
        let backgroundShader;
        let loadedGLBModels = {};
        let modelsToLoad = [
            '6_26_2025 (1).glb',
            '6_28_2025.glb', 
            'camilla-thrilla.glb',
            'dead-coral.glb',
            'dinacam_test2.glb'
        ];
        let modelsLoaded = 0;
        
        // SIMPLIFIED AUDIO SYSTEM - SAMPLES ONLY
        let audioBuffers = {};
        let focusedModelSources = []; // Track all currently playing model sounds
        
        // Model-specific sounds mapping
        const modelSounds = {
            '6_26_2025__1_': 'sounds/sound1.mp3',
            '6_28_2025': 'sounds/sound2.mp3',
            'camilla_thrilla': 'sounds/sound3.mp3',
            'dead_coral': 'sounds/sound4.mp3',
            'dinacam_test2': 'sounds/sound5.mp3'
        };
        
        // Gentle, ocean-like movement
        const baseSpeed = 0.18;
        let currentSpeed = baseSpeed;
        let cameraPath = {
            offset: new THREE.Vector3(0, 0, 0),
            sway: 0,
            bob: 0
        };
        let worldOffset = 0;
        
        // Experience states
        let experienceStates = [
            "Floating...", "Drifting...", "Exploring...", "Dreaming...", 
            "Wandering...", "Discovering...", "Contemplating..."
        ];
        let lastStateChange = 0;

        // Zone system
        const zones = [
            {
                name: "Sunlit Waters",
                depth: 0,
                fogColor: 0x4080ff,
                fogNear: 80,
                fogFar: 200,
                ambientColor: 0x4080aa,
                ambientIntensity: 0.8
            },
            {
                name: "Twilight Depths",
                depth: 300,
                fogColor: 0x2040aa,
                fogNear: 50,
                fogFar: 150,
                ambientColor: 0x2040aa,
                ambientIntensity: 0.5
            },
            {
                name: "Midnight Abyss",
                depth: 800,
                fogColor: 0x001122,
                fogNear: 20,
                fogFar: 80,
                ambientColor: 0x001122,
                ambientIntensity: 0.3
            }
        ];

        // Memory fragments
        const memoryTexts = [
            "Brain Coral",
            "Staghorn Coral",
            "Elkhorn Coral",
            "Fire Coral",
            "Soft Coral",
            "Table Coral",
            "Finger Coral",
            "Mushroom Coral",
            "Star Coral",
            "Plate Coral"
        ];

        let currentMemoryTimeout = null;
        let usedMemoryTexts = new Set();

        // Helper function for center-biased random positioning
        function centerBiasedRandom() {
            const r1 = Math.random();
            const r2 = Math.random();
            return (r1 + r2) / 2 - 0.5;
        }

        // AUDIO SYSTEM - SAMPLES ONLY
        function initAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            loadAudioFiles();
        }

        async function loadAudioFiles() {
            for (const [modelName, soundFile] of Object.entries(modelSounds)) {
                try {
                    const response = await fetch(soundFile);
                    const arrayBuffer = await response.arrayBuffer();
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    audioBuffers[modelName] = audioBuffer;
                    console.log(`Loaded sound for ${modelName}: ${soundFile}`);
                } catch (error) {
                    console.warn(`Failed to load sound for ${modelName}: ${soundFile}`, error);
                }
            }
        }

        function playModelSound(modelName) {
            if (!audioBuffers[modelName]) return null;
            
            const source = audioContext.createBufferSource();
            const gainNode = audioContext.createGain();
            
            source.buffer = audioBuffers[modelName];
            source.loop = true; // Loop the sound while focused
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            
            source.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            source.start();
            
            const audioSource = { source, gainNode };
            focusedModelSources.push(audioSource);
            
            return audioSource;
        }

        function stopAllModelSounds() {
            focusedModelSources.forEach(audioSource => {
                try {
                    audioSource.source.stop();
                } catch (e) {
                    // Source might already be stopped
                }
            });
            focusedModelSources = [];
        }

        // Create ocean-like background shader
        function createBackgroundShader() {
            const vertexShader = `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;
            
            const fragmentShader = `
                uniform float time;
                uniform vec2 resolution;
                varying vec2 vUv;
                
                vec3 palette(float t) {
                    vec3 a = vec3(0.2, 0.3, 0.5);
                    vec3 b = vec3(0.3, 0.4, 0.6);
                    vec3 c = vec3(0.5, 0.7, 1.0);
                    vec3 d = vec3(0.1, 0.2, 0.4);
                    return a + b * cos(6.28318 * (c * t + d));
                }
                
                void main() {
                    vec2 uv = (vUv - 0.5) * 2.0;
                    uv.x *= resolution.x / resolution.y;
                    
                    vec2 uv0 = uv;
                    vec3 finalColor = vec3(0.0);
                    
                    for (float i = 0.0; i < 3.0; i++) {
                        uv = fract(uv * 1.5) - 0.5;
                        
                        float d = length(uv) * exp(-length(uv0));
                        
                        vec3 col = palette(length(uv0) + i * 0.4 + time * 0.1);
                        
                        d = sin(d * 8.0 + time * 0.5) / 8.0;
                        d = abs(d);
                        d = pow(0.01 / d, 1.2);
                        
                        finalColor += col * d;
                    }
                    
                    // Create strong ocean background that shows through gaps
                    float gradient = smoothstep(0.0, 1.0, vUv.y);
                    vec3 oceanBase = mix(vec3(0.3, 0.5, 0.9), vec3(0.1, 0.2, 0.5), gradient);
                    
                    // Multiple wave layers - now we know they work!
                    float wave1 = sin(vUv.x * 12.0 + time * 0.8) * 0.3;
                    float wave2 = sin(vUv.y * 8.0 + time * 0.6) * 0.25;
                    float wave3 = sin((vUv.x - vUv.y) * 6.0 + time * 1.0) * 0.35;
                    float wave4 = sin((vUv.x + vUv.y) * 10.0 + time * 0.4) * 0.2;
                    
                    float wavePattern = wave1 + wave2 + wave3 + wave4;
                    
                    // Ocean-like wave colors (light blue/teal)
                    oceanBase += wavePattern * vec3(0.15, 0.25, 0.35);
                    
                    // Use ocean as base, kaleidoscope as overlay
                    finalColor = oceanBase + finalColor * 0.06;
                    
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `;
            
            const geometry = new THREE.PlaneGeometry(2, 2);
            const material = new THREE.ShaderMaterial({
                vertexShader,
                fragmentShader,
                uniforms: {
                    time: { value: 0 },
                    resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
                }
            });
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(0, 0, -100); // Closer to camera, less fog interference
            mesh.scale.setScalar(300);
            
            return mesh;
        }

        function getRandomMemoryText() {
            if (usedMemoryTexts.size >= memoryTexts.length) {
                usedMemoryTexts.clear();
            }
            
            const availableTexts = memoryTexts.filter(text => !usedMemoryTexts.has(text));
            const selectedText = availableTexts[Math.floor(Math.random() * availableTexts.length)];
            usedMemoryTexts.add(selectedText);
            
            return selectedText;
        }

        function showMemoryText(text) {
            const memoryEl = document.getElementById('memoryText');
            memoryEl.textContent = text;
            memoryEl.style.opacity = '1';
            
            if (currentMemoryTimeout) {
                clearTimeout(currentMemoryTimeout);
            }
            
            currentMemoryTimeout = setTimeout(() => {
                memoryEl.style.opacity = '0';
            }, 3000);
        }

        function updateZone() {
            let currentZone = zones[0];
            
            for (let i = zones.length - 1; i >= 0; i--) {
                if (depth >= zones[i].depth) {
                    currentZone = zones[i];
                    break;
                }
            }
            
            document.getElementById('zoneName').textContent = currentZone.name;
            
            const targetFogColor = new THREE.Color(currentZone.fogColor);
            scene.fog.color.lerp(targetFogColor, 0.01);
            scene.fog.near += (currentZone.fogNear - scene.fog.near) * 0.01;
            scene.fog.far += (currentZone.fogFar - scene.fog.far) * 0.01;
            
            const ambientLight = scene.getObjectByName('ambientLight');
            if (ambientLight) {
                const targetAmbientColor = new THREE.Color(currentZone.ambientColor);
                ambientLight.color.lerp(targetAmbientColor, 0.01);
                ambientLight.intensity += (currentZone.ambientIntensity - ambientLight.intensity) * 0.01;
            }
        }

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x4080ff, 80, 200);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, -2, 0);
            camera.lookAt(0, -5, -20);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x001122); // Darker to let background shader show
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            document.getElementById('gameContainer').appendChild(renderer.domElement);
            
            backgroundShader = createBackgroundShader();
            scene.add(backgroundShader);
            
            const ambientLight = new THREE.AmbientLight(0x4080aa, 0.8);
            ambientLight.name = 'ambientLight';
            scene.add(ambientLight);
            
            const mainLight = new THREE.DirectionalLight(0x88ccff, 0.6);
            mainLight.position.set(10, 20, 10);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            scene.add(mainLight);
            
            const colorLights = [
                { color: 0x4a9fbb, pos: [20, 0, 10], intensity: 0.3 },
                { color: 0x7dd3fc, pos: [-20, 0, 10], intensity: 0.3 },
                { color: 0x60a5fa, pos: [0, 20, -10], intensity: 0.2 }
            ];
            
            colorLights.forEach(lightData => {
                const light = new THREE.PointLight(lightData.color, lightData.intensity, 80);
                light.position.set(...lightData.pos);
                scene.add(light);
            });
            
            loadAllGLBModels();
            setupEventListeners();
            
            document.getElementById('startButton').addEventListener('click', startGame);
        }

        function loadAllGLBModels() {
            const loader = new GLTFLoader();
            const statusEl = document.getElementById('modelStatus');
            
            statusEl.textContent = `Searching for ${modelsToLoad.length} GLB models...`;
            
            modelsToLoad.forEach((modelFile, index) => {
                loader.load(
                    modelFile,
                    (gltf) => {
                        console.log(`GLB loaded successfully: ${modelFile}`, gltf);
                        
                        const model = gltf.scene;
                        
                        const box = new THREE.Box3().setFromObject(model);
                        const center = box.getCenter(new THREE.Vector3());
                        const size = box.getSize(new THREE.Vector3());
                        
                        const maxDim = Math.max(size.x, size.y, size.z);
                        const scale = 8 / maxDim;
                        
                        model.scale.setScalar(scale);
                        model.position.sub(center.multiplyScalar(scale));
                        
                        model.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                                if (child.material) {
                                    child.material.needsUpdate = true;
                                    child.material.emissive = new THREE.Color(0x112244);
                                }
                            }
                        });
                        
                        const modelName = modelFile.replace('.glb', '').replace(/[^a-zA-Z0-9]/g, '_');
                        model.userData = {
                            type: 'polycam_model',
                            name: modelName,
                            filename: modelFile,
                            originalScale: model.scale.clone(),
                            originalPosition: model.position.clone(),
                            floatPhase: Math.random() * Math.PI * 2,
                            focusGlow: 0,
                            targetGlow: 0
                        };
                        
                        loadedGLBModels[modelName] = model;
                        modelsLoaded++;
                        
                        statusEl.textContent = `Loaded ${modelsLoaded}/${modelsToLoad.length}: ${modelFile}`;
                        
                        if (modelsLoaded === modelsToLoad.length) {
                            statusEl.textContent = `Found ${modelsLoaded} models! Ready to explore.`;
                            createInitialWorld();
                        }
                    },
                    (progress) => {
                        const percent = Math.round((progress.loaded / progress.total) * 100);
                        statusEl.textContent = `Loading ${modelFile}... ${percent}%`;
                    },
                    (error) => {
                        console.error(`Error loading GLB model ${modelFile}:`, error);
                        modelsLoaded++;
                        
                        if (modelsLoaded === modelsToLoad.length) {
                            const successCount = Object.keys(loadedGLBModels).length;
                            if (successCount > 0) {
                                statusEl.textContent = `Found ${successCount} models! Ready to explore.`;
                                createInitialWorld();
                            } else {
                                statusEl.textContent = 'No GLB models found. Place GLB files in same directory.';
                                createInitialWorld();
                            }
                        }
                    }
                );
            });
        }

        function setupEventListeners() {
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            window.addEventListener('resize', onWindowResize);
        }

        function createInitialWorld() {
            generateWorldSection(-80);
            generateWorldSection(-40);
            generateWorldSection(0);
            generateWorldSection(40);
        }

        function generateWorldSection(centerZ) {
            const sectionLength = 40;
            const modelNames = Object.keys(loadedGLBModels);
            
            if (modelNames.length > 0) {
                for (let i = 0; i < 3 + Math.floor(Math.random() * 2); i++) {
                    const randomModel = modelNames[Math.floor(Math.random() * modelNames.length)];
                    createPolycamInstance(centerZ + (Math.random() - 0.5) * sectionLength, randomModel);
                }
            }
        }

        function createPolycamInstance(z, modelName) {
            if (!loadedGLBModels[modelName]) return;
            
            const instance = loadedGLBModels[modelName].clone();
            
            const scale = 3 + Math.random() * 4;
            instance.scale.setScalar(scale);
            
            instance.position.set(
                centerBiasedRandom() * 10,
                -11 + Math.random() * 4,
                z
            );
            
            instance.rotation.y = Math.random() * Math.PI * 2;
            
            instance.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    if (child.material) {
                        child.material.emissive = new THREE.Color(0x112244);
                        if (child.material.transparent !== undefined) {
                            child.material.transparent = true;
                            child.material.opacity = 0.9;
                        }
                    }
                }
            });
            
            instance.userData = {
                type: 'polycam_model',
                name: modelName,
                originalScale: instance.scale.clone(),
                originalRotation: instance.rotation.clone(),
                originalPosition: instance.position.clone(),
                floatPhase: Math.random() * Math.PI * 2,
                floatSpeed: 0.008 + Math.random() * 0.004,
                floatAmount: 0.5 + Math.random() * 1.0,
                driftSpeed: (Math.random() - 0.5) * 0.002,
                rotateSpeed: (Math.random() - 0.5) * 0.005,
                focusGlow: 0,
                targetGlow: 0,
                currentScale: instance.scale.clone(),
                audioSource: null, // Track the audio source for this specific model
                isPlaying: false   // Track if sound is currently playing
            };
            
            scene.add(instance);
            worldObjects.push(instance);
            
            if (Math.random() < 0.2) {
                createMemoryOrb(instance.position.clone());
            }
        }

        function createMemoryOrb(position) {
            const orbGeometry = new THREE.SphereGeometry(0.8, 32, 32);
            const orbMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x88ffff,
                transparent: true, 
                opacity: 0.8,
                emissive: 0x224466,
                shininess: 100
            });
            const orb = new THREE.Mesh(orbGeometry, orbMaterial);
            
            // Simple glow effect with two spheres
            const glowGeometry1 = new THREE.SphereGeometry(1.2, 16, 16);
            const glowMaterial1 = new THREE.MeshBasicMaterial({
                color: 0x44ccff,
                transparent: true,
                opacity: 0.4
            });
            const glow1 = new THREE.Mesh(glowGeometry1, glowMaterial1);
            orb.add(glow1);
            
            const glowGeometry2 = new THREE.SphereGeometry(1.6, 12, 12);
            const glowMaterial2 = new THREE.MeshBasicMaterial({
                color: 0x2299cc,
                transparent: true,
                opacity: 0.2
            });
            const glow2 = new THREE.Mesh(glowGeometry2, glowMaterial2);
            orb.add(glow2);
            
            orb.position.copy(position);
            orb.position.y += 3;
            
            orb.userData = {
                type: 'memory',
                text: getRandomMemoryText(),
                bobPhase: Math.random() * Math.PI * 2,
                bobSpeed: 0.01 + Math.random() * 0.005,
                bobAmount: 0.5 + Math.random() * 0.3,
                originalY: orb.position.y,
                activated: false
            };
            
            scene.add(orb);
            worldObjects.push(orb);
        }

        function startGame() {
            if (!gameStarted) {
                gameStarted = true;
                window.spacePressed = false;
                document.getElementById('startButton').style.display = 'none';
                document.getElementById('modelStatus').style.display = 'none';
                initAudio();
                animate();
            }
        }

        function onKeyDown(event) {
            if (!gameStarted) return;
            
            if (event.code === 'Space') {
                event.preventDefault();
                if (!focusMode) {
                    focusMode = true;
                }
                window.spacePressed = true;
            }
        }

        function onKeyUp(event) {
            if (!gameStarted) return;
            
            if (event.code === 'Space') {
                event.preventDefault();
                focusMode = false;
                window.spacePressed = false;
                
                // Stop all model sounds immediately when space is released
                stopAllModelSounds();
                
                // Reset all model sound states
                worldObjects.forEach(obj => {
                    if (obj.userData.type === 'polycam_model') {
                        obj.userData.audioSource = null;
                        obj.userData.isPlaying = false;
                    }
                });
            }
        }

        function updateCameraMovement() {
            const t = time * 0.3;
            
            cameraPath.sway = Math.sin(t * 0.4) * 2;
            cameraPath.bob = Math.sin(t * 0.6) * 0.8;
            
            camera.position.x += (cameraPath.sway - camera.position.x) * 0.02;
            camera.position.y += ((-2 + cameraPath.bob) - camera.position.y) * 0.02;
            
            const lookX = cameraPath.sway * 0.2;
            const lookY = -5 + cameraPath.bob * 0.3;
            const lookZ = camera.position.z - 25;
            
            camera.lookAt(lookX, lookY, lookZ);
            
            camera.rotation.z = Math.sin(t * 0.5) * 0.02;
        }

        function animate() {
            if (!gameStarted) return;
            
            requestAnimationFrame(animate);
            time += 0.016;
            
            if (backgroundShader && backgroundShader.material && backgroundShader.material.uniforms && backgroundShader.material.uniforms.time) {
                backgroundShader.material.uniforms.time.value = time;
            }
            
            updateCameraMovement();
            updateZone();
            
            if (focusMode) {
                focusIntensity = Math.min(focusIntensity + 0.03, 1.0);
                currentSpeed = baseSpeed * 0.3;
            } else {
                focusIntensity = Math.max(focusIntensity - 0.02, 0.0);
                currentSpeed += (baseSpeed - currentSpeed) * 0.01;
            }
            
            const focusBar = document.getElementById('focusBar');
            focusBar.style.width = (focusIntensity * 100) + '%';
            focusBar.style.opacity = focusIntensity;
            
            worldOffset += currentSpeed;
            depth += currentSpeed * 12;
            
            document.getElementById('depth').textContent = Math.floor(depth);
            
            if (time - lastStateChange > 8 + Math.random() * 12) {
                const randomState = experienceStates[Math.floor(Math.random() * experienceStates.length)];
                document.getElementById('experience').textContent = randomState;
                lastStateChange = time;
            }
            
            if (depth % 480 < currentSpeed * 12) {
                generateWorldSection(-worldOffset - 80);
            }
            
            // Update world objects
            worldObjects.forEach((obj, index) => {
                const userData = obj.userData;
                
                obj.position.z += currentSpeed;
                
                if (obj.position.z > camera.position.z + 60) {
                    // Clean up audio source before removing object
                    if (userData.type === 'polycam_model' && userData.audioSource) {
                        try {
                            userData.audioSource.source.stop();
                        } catch (e) {
                            // Source might already be stopped
                        }
                        // Remove from active sources array
                        const index = focusedModelSources.indexOf(userData.audioSource);
                        if (index > -1) {
                            focusedModelSources.splice(index, 1);
                        }
                    }
                    
                    scene.remove(obj);
                    worldObjects.splice(index, 1);
                    return;
                }
                
                if (userData.type === 'polycam_model') {
                    // Gentle floating motion
                    userData.floatPhase += userData.floatSpeed;
                    obj.position.y = userData.originalPosition.y + Math.sin(userData.floatPhase) * userData.floatAmount;
                    
                    // Gentle drifting with bounds checking
                    obj.position.x += userData.driftSpeed;
                    
                    const maxX = 16;
                    if (Math.abs(obj.position.x) > maxX) {
                        obj.position.x = Math.sign(obj.position.x) * maxX;
                        userData.driftSpeed *= -0.4;
                    }
                    
                    obj.rotation.y += userData.rotateSpeed;
                    
                    // Focus effects
                    const distanceToCamera = obj.position.distanceTo(camera.position);
                    const focusDistance = 18;
                    
                    if (focusMode && distanceToCamera < focusDistance) {
                        userData.targetGlow = 1.0;
                        
                        // Play model-specific sound if not already playing
                        if (!userData.isPlaying && !userData.audioSource) {
                            userData.audioSource = playModelSound(userData.name);
                            userData.isPlaying = true;
                        }
                        
                        // Scale effect
                        const targetScale = userData.originalScale.clone().multiplyScalar(1.4);
                        userData.currentScale.lerp(targetScale, 0.02);
                        obj.scale.copy(userData.currentScale);
                        
                        obj.rotation.y += userData.rotateSpeed * 2;
                    } else {
                        userData.targetGlow = 0.0;
                        
                        // Stop model sound when out of focus
                        if (userData.audioSource) {
                            try {
                                userData.audioSource.source.stop();
                            } catch (e) {
                                // Source might already be stopped
                            }
                            // Remove from active sources array
                            const sourceIndex = focusedModelSources.indexOf(userData.audioSource);
                            if (sourceIndex > -1) {
                                focusedModelSources.splice(sourceIndex, 1);
                            }
                            userData.audioSource = null;
                            userData.isPlaying = false;
                        }
                        
                        // Return to normal scale
                        userData.currentScale.lerp(userData.originalScale, 0.01);
                        obj.scale.copy(userData.currentScale);
                    }
                    
                    // Update glow
                    userData.focusGlow += (userData.targetGlow - userData.focusGlow) * 0.03;
                    
                    // Apply glow effect
                    obj.traverse((child) => {
                        if (child.isMesh && child.material && child.material.emissive) {
                            const baseEmissive = new THREE.Color(0x112244);
                            const glowEmissive = new THREE.Color(0x4a9fbb);
                            child.material.emissive.lerpColors(baseEmissive, glowEmissive, userData.focusGlow);
                        }
                    });
                } else if (userData.type === 'memory') {
                    // Gentle bobbing motion for memory orbs
                    userData.bobPhase += userData.bobSpeed;
                    obj.position.y = userData.originalY + Math.sin(userData.bobPhase) * userData.bobAmount;
                    
                    obj.rotation.y += 0.01;
                    obj.rotation.x += 0.005;
                    
                    // Check if player is focusing near this orb
                    const distanceToCamera = obj.position.distanceTo(camera.position);
                    
                    if (focusMode && distanceToCamera < 15 && !userData.activated) {
                        userData.activated = true;
                        showMemoryText(userData.text);
                        
                        // Make orb glow brighter briefly
                        obj.material.opacity = 1.0;
                        obj.material.emissive = new THREE.Color(0x88ffff);
                        
                        setTimeout(() => {
                            obj.material.opacity = 0.8;
                            obj.material.emissive = new THREE.Color(0x224466);
                        }, 2000);
                    }
                }
            });
            
            // Update background to follow camera
            if (backgroundShader) {
                backgroundShader.position.z = camera.position.z - 80; // Closer positioning
                backgroundShader.position.x = camera.position.x * 0.1;
                backgroundShader.position.y = camera.position.y * 0.1;
            }
            
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            if (backgroundShader && backgroundShader.material && backgroundShader.material.uniforms && backgroundShader.material.uniforms.resolution) {
                backgroundShader.material.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
            }
        }

        // Initialize the experience
        init();
    </script>
</body>
</html>